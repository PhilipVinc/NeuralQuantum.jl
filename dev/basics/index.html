<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Basics · NeuralQuantum.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="NeuralQuantum.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">NeuralQuantum.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Manual</span><ul><li class="is-active"><a class="tocitem" href>Basics</a><ul class="internal"><li><a class="tocitem" href="#Defining-the-problem-1"><span>Defining the problem</span></a></li><li><a class="tocitem" href="#Chosing-a-sampler-1"><span>Chosing a sampler</span></a></li><li><a class="tocitem" href="#Stochastic-Reconfiguration-1"><span>Stochastic Reconfiguration</span></a></li><li><a class="tocitem" href="#Solving-the-problem-1"><span>Solving the problem</span></a></li><li><a class="tocitem" href="#Computing-Observables-1"><span>Computing Observables</span></a></li></ul></li><li><a class="tocitem" href="../liouvillian/">Liouvillian</a></li><li><a class="tocitem" href="../networks/">Networks</a></li><li><a class="tocitem" href="../algorithms/">SR</a></li><li><a class="tocitem" href="../optimizers/">Optimizers</a></li></ul></li><li><a class="tocitem" href="../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Basics</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Basics</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/PhilipVinc/NeuralQuantum.jl/blob/master/docs/src/basics.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Basics-1"><a class="docs-heading-anchor" href="#Basics-1">Basics</a><a class="docs-heading-anchor-permalink" href="#Basics-1" title="Permalink"></a></h1><h2 id="Defining-the-problem-1"><a class="docs-heading-anchor" href="#Defining-the-problem-1">Defining the problem</a><a class="docs-heading-anchor-permalink" href="#Defining-the-problem-1" title="Permalink"></a></h2><p>NeuralQuantum&#39;s aim is to compute the steady state of an Open Quantum System or the ground state of an Hamiltonian system. As such, the first step must be defining the quantum system you are interested in.</p><h3 id="Hilbert-space-1"><a class="docs-heading-anchor" href="#Hilbert-space-1">Hilbert space</a><a class="docs-heading-anchor-permalink" href="#Hilbert-space-1" title="Permalink"></a></h3><p>First, you should pick an hilbert space. As of now, only homogeneous Hilbert spaces are supported, <a href="../reference/#NeuralQuantum.HomogeneousFock"><code>HomogeneousFock</code></a> or <a href="../reference/#NeuralQuantum.HomogeneousSpin"><code>HomogeneousSpin</code></a> If you wish, for example, to model 5 spin-1/2 particles you can create the Hilbert space as follows:</p><pre><code class="language-julia">julia&gt; using NeuralQuantum

julia&gt; N = 5;
julia&gt; hilb = HomogeneousSpin(N, 1//2)
Hilbert Space with 5 identical spins 1/2 of dimension 2

julia&gt; shape(hilb)
5-element Array{Int64,1}:
 2 2 2 2 2

julia&gt; state(hilb)
5-element Array{Float32,1}:
 -1.0 -1.0 -1.0 -1.0 -1.0</code></pre><p>!!! Spin vs Fock Space    You could also model the space as a Fock space with local dimension 2. This choice is formally equivalent, but in this case the states don&#39;t have values [-1.0, 1.0] but will take on the values [0.0, 1.0]. This can be useful sometimes when working with some networks. In general, the spin-space works better with <code>logcosh</code> activation function, while fock space works better with <code>softplus</code> activation function.</p><h3 id="Building-an-Hamiltonian-1"><a class="docs-heading-anchor" href="#Building-an-Hamiltonian-1">Building an Hamiltonian</a><a class="docs-heading-anchor-permalink" href="#Building-an-Hamiltonian-1" title="Permalink"></a></h3><p>To build an hamiltonian, you cannot use simple matrices. Instead, you should use our custom format that behaves similarly to a sparse matrix, but has a few additional tricks that allows us to be efficient in the kind of calculations that Variational Monte Carlo requires. To build an Hamiltonian, the simplest way is to use the standard pauli-matrices and bosonic creation/destruction operators, and compose them:</p><pre><code class="language-julia">julia&gt; h = 1.0; J=1.0;
julia&gt; H = LocalOperator(hilb)
empty KLocalOperator on space:  HomogeneousSpin(5, 2)

julia&gt; for i=1:N
         global H  -= h * sigmax(hilb, i)
       end
KLocalOperatorSum:
   -sites: Array{Int64,1}[[1], [2], [3], [4], [5]]

julia&gt; for i=1:N
         global H  += J * sigmaz(hilb, i) * sigmaz(hilb, mod(i, N)+1)
       end
KLocalOperatorSum:
  -sites: Array{Int64,1}[[1], [2], [3], [4], [5], [1, 2], [2, 3], [3, 4], [4, 5], [1, 5]]</code></pre><p>The built-in operators are <a href="../reference/#QuantumOpticsBase.sigmax"><code>sigmax</code></a>, <a href="../reference/#QuantumOpticsBase.sigmay"><code>sigmay</code></a>, <a href="../reference/#QuantumOpticsBase.sigmaz"><code>sigmaz</code></a>, <a href="../reference/#QuantumOpticsBase.sigmap"><code>sigmap</code></a>,  <a href="../reference/#QuantumOpticsBase.sigmam"><code>sigmam</code></a> and <a href="../reference/#QuantumOpticsBase.create"><code>create</code></a>, <a href="../reference/#QuantumOpticsBase.destroy"><code>destroy</code></a>. They support all the standard operations (transpose, conjugate, conjugate transpose).</p><p>You can also create your custom N-body operators, by specifying an hilbert space, the list of sites upon which it acts, and the matrix in the reduced space of the sites where it acts. For example, to build by yourself the <code>sigmaz_1 * sigmaz_2</code> operator you can do the following:</p><pre><code class="language-julia">julia&gt; sites = [1,2]
julia&gt; mat = diagm(0=&gt;[1.0, -1.0, -1.0, 1.0])
julia&gt; KLocalOperatorRow(hilb, [1,2],  complex.(mat))
KLocalOperator(Complex{Float64})
  Hilb: HomogeneousSpin(5, 2)
  sites: [1, 2]  (size: [2, 2])
 1.0 + 0.0im   0.0 + 0.0im   0.0 + 0.0im  0.0 + 0.0im
 0.0 + 0.0im  -1.0 + 0.0im   0.0 + 0.0im  0.0 + 0.0im
 0.0 + 0.0im   0.0 + 0.0im  -1.0 + 0.0im  0.0 + 0.0im
 0.0 + 0.0im   0.0 + 0.0im   0.0 + 0.0im  1.0 + 0.0im</code></pre><h3 id="Choosing-a-Neural-Network-State-1"><a class="docs-heading-anchor" href="#Choosing-a-Neural-Network-State-1">Choosing a Neural Network State</a><a class="docs-heading-anchor-permalink" href="#Choosing-a-Neural-Network-State-1" title="Permalink"></a></h3><p>You should pick a state from those listed in <a href="@ref">Networks</a>. In the following we will pick a simple restricted Boltmann Machine (RBM).</p><pre><code class="language-julia">net  = RBM(Float32, N, 1, af_logcosh)</code></pre><p>In general, when working with neural networks, the first argument is an optional type for the parameters, the second is the number of sites in the system, and the others depend on the network. In the case of the RBM, the third argument is the density of the hidden layer, and the last argument is the activation function. In general we have seen that best performance is found by combining logcosh activation with spin-hilbert spaces.</p><p>When you create a network, it has all it&#39;s weights distributed according to a gaussian with standard deviation 0.005. You can also reinitialize all weights with a gaussian distribution by using the command <a href="@ref"><code>init_random_pars!</code></a>.</p><pre><code class="language-julia">julia&gt; init_random_pars!(net, sigma=0.01)</code></pre><h2 id="Chosing-a-sampler-1"><a class="docs-heading-anchor" href="#Chosing-a-sampler-1">Chosing a sampler</a><a class="docs-heading-anchor-permalink" href="#Chosing-a-sampler-1" title="Permalink"></a></h2><p>The sampler is the algorithm that selects the states in the hilbert space to be summed over. Options are <a href="@ref"><code>Exact</code></a>, which computes the whole probability distribution and samples exactly, but is very expensive and only works for relatively small (N&lt;10) systems.</p><p>In general, you will be using a <a href="../reference/#NeuralQuantum.MetropolisSampler"><code>MetropolisSampler</code></a>, which uses a Metropolis-Hastings Markov Chain with a specific transition rule. Currently only a simple switching rule and an exchange rule are implemented.</p><pre><code class="language-julia">sampler = MetropolisSampler(LocalRule(), 125, N, burn=100)</code></pre><p>The first argument is the rule, the second argument is the length of each chain, the third argument is the number of times the LocalRule should be applied at every iteration (and should be of the order N). <code>burn</code> is an optional keyword argument with the number of unused iterations after the chain is resetted.</p><h2 id="Stochastic-Reconfiguration-1"><a class="docs-heading-anchor" href="#Stochastic-Reconfiguration-1">Stochastic Reconfiguration</a><a class="docs-heading-anchor-permalink" href="#Stochastic-Reconfiguration-1" title="Permalink"></a></h2><p>While it is possible to find the ground state with simple gradient descent, much better efficiency is achieved when the networks have less than 5000 parameters by using Natural Gradient Descent, or Stochastic Reconfiguration, which is somewhat equivalent to a second order newton method.</p><p>The stochastic reconfiguration essentially builds a local approximation of the metric, called S-matrix, and solves the equation <span>$\delta x = S^{-1} \nabla C$</span> where <span>$C$</span> is the cost function (the energy). This equation can be solved either by inversion or by using an iterative solver, which is much more efficient. Type <code>?SR</code> in julia to see it&#39;s documentation.</p><pre><code class="language-julia">algo  = SR(ϵ=(0.1), algorithm=sr_cg, precision=1e-3)</code></pre><p>Notable arguments are <code>ϵ</code>, which is the diagonal shift of the S matrix when inverting, the precision of the iterative solver and the algorithm used.</p><h2 id="Solving-the-problem-1"><a class="docs-heading-anchor" href="#Solving-the-problem-1">Solving the problem</a><a class="docs-heading-anchor-permalink" href="#Solving-the-problem-1" title="Permalink"></a></h2><p>All is set. You now only need to construct a <code>BatchedSampler</code> (which is a weird name for the object actually effecting the sampling) and optimise the weights</p><pre><code class="language-julia">is = BatchedSampler(net, sampl, H, algo; batch_sz=8)
optimizer = Optimisers.Descent(0.1)

Evalues = Float64[];
Eerr = Float64[];
for i=1:300
    ldata, prec = sample!(is)
    ob = compute_observables(is)

    push!(Evalues, real(ldata.mean))
    push!(Eerr, ldata.error)
    grad = precondition!(prec, algo, i)
    Optimisers.update!(optimizer, net, grad)
end</code></pre><p>That&#39;s it. At every iteration <code>sample!(is)</code> will return two elements: the value of the cost function (with it&#39;s error) and an object containing data to compute the gradient, which is computed by <code>precondition!</code>.</p><h2 id="Computing-Observables-1"><a class="docs-heading-anchor" href="#Computing-Observables-1">Computing Observables</a><a class="docs-heading-anchor-permalink" href="#Computing-Observables-1" title="Permalink"></a></h2><p>If you wish to compute observables, you simply need to compose the operator that represent the observable, and then add it to the <code>BatchedSampler</code> by doing</p><pre><code class="language-julia">julia&gt; Sx = LocalOperator(hilb)
julia&gt; for i=1:N
          global Sx += sigmax(hilb, i)/N
       end

julia&gt; add_observable!(is, &quot;Sx&quot;, Sx)</code></pre><p>From now on, if you call <code>compute_observables(is)</code> you will obtain a dictionary with all the observables computed. Observables are computed by using the same Markov Chain used to estimate the energy (cost function) to be minimised for hamiltonian systems. In the case of Open Quantum Systems a different markov chain is used.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../liouvillian/">Liouvillian »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 8 January 2020 09:23">Wednesday 8 January 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
